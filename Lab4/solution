#include <cmath>
#include <iostream>
#include <random>
#include <vector>
#include <fstream>
#include <utility>
#include <iomanip>
#include <array>  // <<< === added for std::array

#include "utils.h"
#include "render.h"

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++Modify my_robot class here+++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class my_robot : public Object {     // <<< === now inherits from Object
public:
    int lidar_range = 50;
    std::vector<std::vector<int>> grid;
    int tol = 20;                    // <<< === tolerance distance for wall checks
    // constructor
    my_robot(int width, int height, int env_width, int min_y, int max_y, int tol)
        : Object(width, height, env_width, min_y, max_y, tol) {
        grid = std::vector<std::vector<int>>(800, std::vector<int>(800, -1));
        this->tol = tol;
    }

    // sense function (same as before)
    void sense(grid_util& g) {
        int xc = this->x + this->width / 2;
        int yc = this->y + this->height / 2;

        for (int i = xc - lidar_range; i <= xc + lidar_range; ++i) {
            for (int j = yc - lidar_range; j <= yc + lidar_range; ++j) {
                if (i >= 0 && i < 800 && j >= 0 && j < 800) {
                    int dx = i - xc;
                    int dy = j - yc;
                    if (dx * dx + dy * dy <= lidar_range * lidar_range) {
                        grid[i][j] = Object::grid_value(g, this, i, j, lidar_range);
                    }
                }
            }
        }
    }

    // <<< === NEW: 8-direction wall detection

    // ============================================================
// ============ New function: find_dir() ======================
// ============================================================
std::pair<int,int> find_dir(std::array<int,4> mode, bool clockwise = true) {
    // mode = {x, y, v, w}
    int x = mode[0], y = mode[1], v = mode[2], w = mode[3];
    int wx = 0, wy = 0;

    // --- Determine wall vector (wx, wy) based on which direction is hit ---
    if (x != 0)      wx = x;
    if (y != 0)      wy = y;
    if (v == 1) { wx =  1; wy =  1; }   // bottom-right
    if (v == -1) { wx = -1; wy = -1; }  // top-left
    if (w == 1) { wx =  1; wy = -1; }   // top-right
    if (w == -1) { wx = -1; wy =  1; }  // bottom-left

    int dx, dy;
    if (clockwise) {
        dx = -wy;  // rotate 90° clockwise
        dy =  wx;
    } else {
        dx =  wy;  // rotate 90° counter-clockwise
        dy = -wx;
    }

    // normalize to step of size 1 (so moves 1 px each frame)
    if (dx > 1) dx = 1; if (dx < -1) dx = -1;
    if (dy > 1) dy = 1; if (dy < -1) dy = -1;

    return {dx, dy};
}


  std::array<int,4> detect_walls_8() {
    int xc = this->x + this->width / 2;
    int yc = this->y + this->height / 2;
    int tol45 = static_cast<int>(std::round(this->tol * 0.70710678));

    int x = 0, y = 0, v = 0, w = 0;

    auto in_bounds = [](int a) { return (a >= 0 && a < 800); };

    // Horizontal (right / left)
    if (in_bounds(xc + tol) && in_bounds(yc) && this->grid[xc + tol][yc] == 1)
        x = 1;
    else if (in_bounds(xc - tol) && in_bounds(yc) && this->grid[xc - tol][yc] == 1)
        x = -1;

    // Vertical (bottom / top)
    if (in_bounds(xc) && in_bounds(yc + tol) && this->grid[xc][yc + tol] == 1)
        y = 1;
    else if (in_bounds(xc) && in_bounds(yc - tol) && this->grid[xc][yc - tol] == 1)
        y = -1;

    // Diagonal v (bottom-right / top-left)
    if (in_bounds(xc + tol45) && in_bounds(yc + tol45) && this->grid[xc + tol45][yc + tol45] == 1)
        v = 1;
    else if (in_bounds(xc - tol45) && in_bounds(yc - tol45) && this->grid[xc - tol45][yc - tol45] == 1)
        v = -1;

    // Diagonal w (top-right / bottom-left)
    if (in_bounds(xc + tol45) && in_bounds(yc - tol45) && this->grid[xc + tol45][yc - tol45] == 1)
        w = 1;
    else if (in_bounds(xc - tol45) && in_bounds(yc + tol45) && this->grid[xc - tol45][yc + tol45] == 1)
        w = -1;

    return {x, y, v, w};
}


    // same save_grid_csv as before
    void save_grid_csv() {
        std::string filename = "grid_pred.csv";
        std::ofstream file(filename);

        if (!file.is_open()) {
            std::cerr << "Error: Could not open file " << filename << std::endl;
            return;
        }

        size_t maxRowSize = 0;
        for (const auto& col : grid)
            if (col.size() > maxRowSize)
                maxRowSize = col.size();

        for (size_t row = 0; row < maxRowSize; ++row) {
            for (size_t col = 0; col < grid.size(); ++col) {
                if (row < grid[col].size()) file << grid[col][row];
                if (col < grid.size() - 1) file << ",";
            }
            file << "\n";
        }

        file.close();
        std::cout << "Robot's grid written to " << filename << std::endl;
    }
};
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//===== Main parameters =====
const int env_width {800}, env_height {800};
const int radius {10};
const int min_obj_size {50};
const int max_obj_size {100};
int lidar_range{50};

grid_util grid(env_width, env_height, min_obj_size, max_obj_size);
random_generator rand_gen;
std::vector<std::vector<int>> robot_pos;

int main(int argc, char const *argv[]) {
    //==========CREATE ROBOT AND WALLS==========
    std::tuple<std::string, bool, int, int> config = read_csv();

    std::vector<Object*> walls;
    if (std::get<3>(config) == 4){
        walls = grid.create_walls(std::get<0>(config));
    }
    else
        walls = grid.create_angled_walls(std::get<0>(config));

    int min_y_spawn = grid.get_min_y();
    int max_y_spawn = grid.get_max_y();

    // <<< === Create my_robot instead of Object
    my_robot robot(2*radius, 2*radius, env_width, min_y_spawn, max_y_spawn, radius + 5);
    my_robot robot_init = robot;

    robot_pos.push_back({robot.x, robot.y});
    int limit_count = 0;

    // MAIN LOOP — only detection logic for now
    while (true) {
        limit_count++;

        // 1. Sense environment (Lidar)
        robot.sense(grid);

        // 2. Detect walls (8-direction)
        auto mode = robot.detect_walls_8();

        auto dir = robot.find_dir(mode, true);  // true = clockwise

        if (mode[0] == 0 && mode[1] == 0 && mode[2] == 0 && mode[3] == 0) {
            dir = {1, 0};   // move right until we find a wall
        }

        // 3. Print result (so you can test wall detection)
        std::cout << "Step " << limit_count
                  << " | x:" << mode[0]
                  << " y:" << mode[1]
                  << " v:" << mode[2]
                  << " w:" << mode[3]
                  << std::endl;

        // 4. Temporarauto dir = robot.find_dir(mode, true);  // true = clockwise
        robot.x += dir.first;
    robot.y += dir.second;


        robot_pos.push_back({robot.x, robot.y});

        if (limit_count >= 7200) {
            std::cout << "====Program terminated after 7200 iterations====" << std::endl;
            break;
        }
    }

    // Final evaluation — uses robot.grid now
    std::cout << std::fixed << std::setprecision(2);
    float wall_accuracy = grid.wall_accuracy(robot.grid);
    float accuracy = grid.grid_accuracy(robot.grid);
    std::cout << "Percent of walls correctly mapped: " << wall_accuracy * 100.0 << "%" << std::endl;
    std::cout << "Percent of environment correctly mapped: " << accuracy * 100.0 << "%" << std::endl;

    if (std::get<1>(config))
        render_window(robot_pos, walls, robot_init, env_width, env_height, std::get<2>(config));

    render_grid(robot_init, robot_pos, robot.grid, env_width, env_height, radius, lidar_range, std::get<2>(config));
    return 0;
}
